/*
 * Copyright 2010 JBoss Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.optaplanner.examples.cheaptime.solver;
    dialect "java"

import java.util.List;
import java.util.ArrayList;

import org.optaplanner.core.api.score.buildin.hardmediumsoftlong.HardMediumSoftLongScoreHolder;

import org.optaplanner.examples.cheaptime.domain.CheapTimeSolution;
import org.optaplanner.examples.cheaptime.domain.Machine;
import org.optaplanner.examples.cheaptime.domain.MachineCapacity;
import org.optaplanner.examples.cheaptime.domain.PeriodPowerPrice;
import org.optaplanner.examples.cheaptime.domain.Task;
import org.optaplanner.examples.cheaptime.domain.TaskAssignment;
import org.optaplanner.examples.cheaptime.domain.TaskRequirement;
import org.optaplanner.examples.cheaptime.solver.CheapTimeCostCalculator;
import org.optaplanner.examples.cheaptime.solver.drools.IdleCost;
import org.optaplanner.examples.cheaptime.solver.drools.Period;
import org.optaplanner.examples.cheaptime.solver.drools.MachinePeriodPart;
import org.optaplanner.examples.cheaptime.solver.drools.MachinePeriodStatus;

global HardMediumSoftLongScoreHolder scoreHolder;

// Setup
rule "period"
    salience 3
    when
        CheapTimeSolution($globalPeriodRangeFrom : globalPeriodRangeFrom, $globalPeriodRangeTo : globalPeriodRangeTo)
    then
        for (int i = $globalPeriodRangeFrom; i < $globalPeriodRangeTo; i++) {
            insert(new Period(i));
        }
end

// Introduce MachinePeriodPart to score efficiently
rule "machinePeriodPart"
    salience 2
    when
        CheapTimeSolution($resourceList : resourceList)
        Period($period : period);
        $machine : Machine()
        $taskAssignmentList : ArrayList() from collect (
            TaskAssignment(
                machine == $machine,
                startPeriod <= $period,
                $task: task,
                startPeriod + $task.duration > $period)
        )
    then
        insertLogical(new MachinePeriodPart($machine, $period, $resourceList.size(), $taskAssignmentList));
end

// ############################################################################
// Hard constraints
// ############################################################################

// Start time limits: each task must start between its earliest start and latest start limit.
rule "startTimeLimitsFrom"
    when
        $taskAssignment : TaskAssignment($task : task, $startPeriod : startPeriod < $task.startPeriodRangeFrom)
    then
        //System.out.println("startTimeLimitsFrom");
        scoreHolder.addHardConstraintMatch(kcontext, $startPeriod - $task.getStartPeriodRangeFrom());
end

rule "startTimeLimitsTo"
    when
        $taskAssignment : TaskAssignment($task : task, $startPeriod : startPeriod >= $task.startPeriodRangeTo)
    then
        //System.out.println("startTimeLimitsTo");
        scoreHolder.addHardConstraintMatch(kcontext, $task.getStartPeriodRangeTo() - $startPeriod);
end

// Maximum capacity: the maximum capacity for each resource for each machine must not be exceeded.
rule "maximumCapacity"
    when
        $machinePeriodPart : MachinePeriodPart()
    then
        long resourceAvailableTotal = 0;
        for (int resourceAvailable : $machinePeriodPart.getResourceAvailableList()) {
            if (resourceAvailable < 0) {
                //System.out.println("resourceCapacity : " + $machinePeriodPart + ", resourceAvailable = " + resourceAvailable);
                resourceAvailableTotal += resourceAvailable;
            }
        }
        scoreHolder.addHardConstraintMatch(kcontext, resourceAvailableTotal);
end

// Startup and shutdown: each machine must be active in the periods during which it has assigned tasks.
//   Between tasks it is allowed to be idle to avoid startup and shutdown costs.

//     -> no rule is required because it's implemented in MachinePeriodPart

// ############################################################################
// Medium constraints
// ############################################################################

// Machine power cost: Each active or idle machine consumes power,
//   which infers a power cost (depending on the power price during that time).

// Machine startup and shutdown cost: Every time a machine starts up or shuts down, an extra cost is inflicted.

rule "calculateIdleCost"
    salience 1
    when
        MachinePeriodPart($machine : machine, $period : period, status == MachinePeriodStatus.ACTIVE)
        exists MachinePeriodPart(machine == $machine, period < $period, status == MachinePeriodStatus.ACTIVE)
        exists MachinePeriodPart(machine == $machine, period == $period - 1, status == MachinePeriodStatus.OFF)
        accumulate (
            MachinePeriodPart(machine == $machine, $activePeriod : period < $period, status == MachinePeriodStatus.ACTIVE);
            $lastActivePeriod : max($activePeriod)
        )
        $idlePeriodPowerPriceList : ArrayList() from collect (
            PeriodPowerPrice(
                period > $lastActivePeriod.intValue(),
                period < $period)
        )
    then
        long idleCost = 0;
        for (Object obj : $idlePeriodPowerPriceList) {
            PeriodPowerPrice idlePeriodPowerPrice = (PeriodPowerPrice)obj;
            idleCost += CheapTimeCostCalculator.multiplyTwoMicros($machine.getPowerConsumptionMicros(), idlePeriodPowerPrice.getPowerPriceMicros());
        }
        insertLogical(new IdleCost($machine, $period, idleCost));
end

rule "machinePowerCostActive"
    when
        MachinePeriodPart($machine : machine, $period : period, status == MachinePeriodStatus.ACTIVE)
        $periodPowerPrice : PeriodPowerPrice(period == $period)
    then
        //long cost = CheapTimeCostCalculator.multiplyTwoMicros($machine.getPowerConsumptionMicros(), $periodPowerPrice.getPowerPriceMicros());
        //System.out.println("[machinePowerCostActive] : $machine = " + $machine + ", $period = " + $period + ", cost = " + cost);
        scoreHolder.addMediumConstraintMatch(kcontext,
            - CheapTimeCostCalculator.multiplyTwoMicros($machine.getPowerConsumptionMicros(), $periodPowerPrice.getPowerPriceMicros()));
end

rule "machinePowerCostOffToActive"
    when
        MachinePeriodPart($machine : machine, $period : period, status == MachinePeriodStatus.ACTIVE)
        IdleCost(machine == $machine, activePeriodAfterIdle == $period, $idleCost : cost >= $machine.spinUpDownCostMicros)
    then
        //System.out.println("[machinePowerCostOffToActive] : $machine = " + $machine + ", $period = " + $period
        // + ", idle = " + $idleCost + " vs spin = " + $machine.getSpinUpDownCostMicros());
        scoreHolder.addMediumConstraintMatch(kcontext, - $machine.getSpinUpDownCostMicros());
end

rule "machinePowerCostIdleToActive"
    when
        MachinePeriodPart($machine : machine, $period : period, status == MachinePeriodStatus.ACTIVE)
        IdleCost(machine == $machine, activePeriodAfterIdle == $period, $idleCost : cost < $machine.spinUpDownCostMicros)
    then
        //System.out.println("[machinePowerCostIdleToActive] : $machine = " + $machine + ", $period = " + $period
        // + ", idle = " + $idleCost + " vs spin = " + $machine.getSpinUpDownCostMicros());
        scoreHolder.addMediumConstraintMatch(kcontext, - $idleCost);
end

rule "firstBoot"
    when
        MachinePeriodPart($machine : machine, $period : period, status == MachinePeriodStatus.ACTIVE)
        not MachinePeriodPart(machine == $machine, period < $period, status == MachinePeriodStatus.ACTIVE);
    then
        //System.out.println("[firstBoot] : $machine = " + $machine + ", $period = " + $period);
        scoreHolder.addMediumConstraintMatch(kcontext, - $machine.getSpinUpDownCostMicros());
end

// Task power cost: Each task consumes power too, which infers a power cost (depending on the power price during its time).
rule "taskPowerCost"
    when
        MachinePeriodPart($period : period, status == MachinePeriodStatus.ACTIVE, $taskAssignmentList : taskAssignmentList)
        TaskAssignment(this memberOf $taskAssignmentList, $task : task)
        $periodPowerPrice : PeriodPowerPrice(period == $period)
    then
        //long cost = CheapTimeCostCalculator.multiplyTwoMicros($task.getPowerConsumptionMicros(), $periodPowerPrice.getPowerPriceMicros());
        //System.out.println("[taskPowerCost] : $task = " + $task + ", $period = " + $period + ", cost = " + cost);
        scoreHolder.addMediumConstraintMatch(kcontext,
            - CheapTimeCostCalculator.multiplyTwoMicros($task.getPowerConsumptionMicros(), $periodPowerPrice.getPowerPriceMicros()));
end

// ############################################################################
// Soft constraints
// ############################################################################

// Start early: prefer starting a task sooner rather than later.
rule "startEarly"
    when
        TaskAssignment($startPeriod : startPeriod != null)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, - $startPeriod);
end
